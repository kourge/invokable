# invokable

A way to make invokable JavaScript objects. Reminiscent of Python's [`__call__`](https://docs.python.org/3/reference/datamodel.html#object.__call__).

* [Installation](#installation)
* [Usage](#usage)
* [Capabilities and Limitations](#capabilities-and-limitations)
* [TypeScript Support](#typescript-support)

## Installation

```bash
npm install invokable
```

## Usage

Using with a class:

```js
import {Invokable} from 'invokable';

class Rect {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    return Invokable.create(this);
  }

  get area() {
    return this.width * this.height;
  }

  [Invokable.call](depth = 1) {
    return this.area * depth;
  }
}
```

* Implement a method with the computed name `[Invokable.call]` with any
  signature of your choice.
* End the constructor with `return Invokable.create(this)`

Also works with a plain object:

```js
import {Invokable} from 'invokable';

const Rect = (width, height) =>
  Invokable.create({
    width,
    height,
    get area() {
      return this.width * this.height;
    },
    [Invokable.call](depth = 1) {
      return this.area * depth;
    },
  });
```

* Declare a property with the computed name `[Invokable.call]` with any
  function of your choice.
* Pass the entire object to `Invokable.create`

## Capabilities and Limitations

`Invokable.create` can:

* Preserve the `this` context of the object.
* Do the right thing when an object's `[Invokable.call]` method has been
  replaced at runtime.
* Replicate all properties without triggering getters and setters.
* Inherit the same prototype, ensuring things like `constructor` and the
  `instanceof` operator still work.
* Create functions whose `name` property is writable. Simply define a `name`
  property in the original target object.

It cannot:

* Modify the original object. A new object that masquerades as the original is
  returned.
* Do anything with an object that does not implement `[Invokable.call]`. A
  `TypeError` is thrown when such an object is given.
* Work on JavaScript engines that don't support `Object.setPrototype`,
  `Object.getOwnPropertyDescriptors`, and `Object.defineProperties`, unless
  they have been polyfilled.
* Be rebound using `.bind(...)`. However, the `[Invokable.call]` method can
  still be rebound.

## TypeScript Support

TypeScript support comes out of the box without any additional setup. Here is
the TypeScript version of the class example:

```ts
import {Invokable} from 'invokable';

class Rect {
  constructor(public width: number, public height: number) {
    return Invokable.create(this);
  }

  get area() {
    return this.width * this.height;
  }

  [Invokable.call](depth = 1) {
    return this.area * depth;
  }
}

interface Rect {
  (depth?: number): number;
}
```

Note that it is necessary to modify the interface generated by the class in
order make class instances callable to the type system.

The TypeScript version of the plain object example:

```ts
import {Invokable} from 'invokable';

const Rect = (width: number, height: number) =>
  Invokable.create({
    width,
    height,
    get area() {
      return this.width * this.height;
    },
    [Invokable.call](depth = 1) {
      return this.area * depth;
    },
  });
```
